name: CI/CD Pipeline

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/**'
      - 'README.md'
      - 'CHANGELOG.md'
      - 'package.json'
      - 'pnpm-lock.yaml'
  pull_request:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'README.md'
      - 'CHANGELOG.md'
      - 'package.json'
      - 'pnpm-lock.yaml'

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref_name }}
  cancel-in-progress: true

permissions:
  contents: write
  id-token: write
  pull-requests: write

env:
  REGION: asia-southeast1
  DEV_PROJECT: the-white-dev-481217
  PROD_PROJECT: the-white-prod-481217

jobs:
  check-skip:
    name: Check if CI should be skipped
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.check.outputs.skip }}
      is-release-commit: ${{ steps.check.outputs.is-release-commit }}
    steps:
      - name: Check commit message
        id: check
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            COMMIT_MSG="${{ github.event.pull_request.title }}"
          else
            COMMIT_MSG="${{ github.event.head_commit.message || github.event.commits[0].message }}"
          fi

          # Check for skip patterns
          if echo "$COMMIT_MSG" | grep -qiE "\[skip ci\]|\[ci skip\]|\[skip actions\]|\[actions skip\]"; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "â­ï¸  CI/CD skipped due to commit message"
            exit 0
          fi

          # Check if this is a release commit (chore(release): X.X.X)
          if echo "$COMMIT_MSG" | grep -qE "^chore\(release\):"; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "is-release-commit=true" >> $GITHUB_OUTPUT
            echo "â­ï¸  Release commit detected - skipping workflow (tag will trigger deploy)"
            exit 0
          fi

          echo "skip=false" >> $GITHUB_OUTPUT
          echo "is-release-commit=false" >> $GITHUB_OUTPUT
          echo "âœ… CI/CD will run"

  quality:
    name: Quality Checks
    runs-on: ubuntu-latest
    needs: check-skip
    if: github.event_name == 'pull_request' && needs.check-skip.outputs.skip != 'true'
    steps:
      - name: Generate GitHub App Token
        id: app-token
        if: github.event_name == 'pull_request'
        uses: actions/create-github-app-token@v1
        continue-on-error: true
        with:
          app-id: ${{ secrets.RELEASE_BOT_CLIENT_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}
          installation-id: ${{ secrets.RELEASE_BOT_INSTALLATION_ID }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token || secrets.GITHUB_PAT || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Cache TypeScript build info
        uses: actions/cache@v4
        with:
          path: .next/cache/.tsbuildinfo
          key: ${{ runner.os }}-tsbuildinfo-${{ hashFiles('**/tsconfig.json', '**/*.ts', '**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-tsbuildinfo-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Auto-fix formatting
        id: format
        run: |
          pnpm format || true
          if ! git diff --quiet; then
            git add -A
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit formatting fixes
        if: github.event_name == 'pull_request' && steps.format.outputs.has_changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          if ! git diff --staged --quiet; then
            git commit -m "style: auto-fix formatting issues" || exit 0
            git push origin HEAD:${{ github.head_ref }} || true
          fi

      - name: Verify formatting
        run: pnpm format:check

      - name: Run linter
        run: pnpm lint

      - name: Type check
        run: npx tsc --noEmit

  build:
    name: Build (CI Validation)
    runs-on: ubuntu-latest
    needs: [check-skip, quality]
    if: github.event_name == 'pull_request' && needs.check-skip.outputs.skip != 'true'
    # Note: This is a fast CI validation build (pnpm build) that doesn't create Docker images.
    # Docker builds and deployments happen in the deploy job (GitHub Actions only, no Cloud Build).
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Cache Next.js build
        uses: actions/cache@v4
        with:
          path: |
            .next/cache
            .next/cache/.tsbuildinfo
          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**/*.ts', '**/*.tsx', '**/next.config.js') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Ensure Next.js cache directory exists
        run: mkdir -p .next/cache

      - name: Build application
        run: pnpm build
        env:
          NODE_ENV: production
          NEXT_PUBLIC_SERVER_URL: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && 'https://fashion-web-dev-XXXXXX.run.app' || 'http://localhost:3000' }}
          PAYLOAD_SECRET: dummy-secret-for-build
          DATABASE_URI: postgres://dummy:dummy@localhost:5432/dummy

  # Stage 4: Create release and deploy to prod
  create-github-release:
    name: 'Stage 4: Create Release & Deploy Prod'
    runs-on: ubuntu-latest
    needs: check-skip
    if: github.event_name == 'push' && github.ref_type == 'tag' && needs.check-skip.outputs.skip != 'true'
    environment:
      name: prod
    permissions:
      contents: write
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version
        id: version
        run: |
          VERSION=${GITHUB_REF_NAME#v}
          echo "tag=$GITHUB_REF_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Get changelog
        id: changelog
        run: |
          if [ -f "CHANGELOG.md" ]; then
            CHANGELOG=$(awk -v version="${{ steps.version.outputs.version }}" '
              BEGIN { found=0; in_section=0 }
              /^## \[/ {
                if (match($0, "\\[" version "\\]")) {
                  found=1
                  in_section=1
                  next
                }
                if (in_section && /^## \[/) { exit }
              }
              in_section && !/^## \[/ { print }
            ' CHANGELOG.md | sed '/^$/d' || echo "")
            if [ -n "$CHANGELOG" ]; then
              echo "changelog<<EOF" >> $GITHUB_OUTPUT
              echo "$CHANGELOG" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            fi
          fi

      # WIF: Authenticate to prod project (prod SA has read access to dev registry via IAM)
      - name: Authenticate to Google Cloud - Prod (WIF)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER_PROD }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      # TEMPORARY: Verify WIF authentication is working
      - name: Verify WIF Authentication
        run: |
          echo "ðŸ” Verifying WIF authentication (prod)..."
          echo "=========================================="

          # Check current authenticated account
          echo "ðŸ“‹ Current authenticated account:"
          gcloud auth list || echo "âŒ Failed to list auth accounts"

          # Test basic GCP access
          echo ""
          echo "ðŸ“‹ Testing GCP access..."
          if gcloud projects describe "${{ env.PROD_PROJECT }}" --format="value(projectId)" > /dev/null 2>&1; then
            echo "âœ… Successfully accessed project: ${{ env.PROD_PROJECT }}"
          else
            echo "âŒ Failed to access project: ${{ env.PROD_PROJECT }}"
            exit 1
          fi

          # Test Artifact Registry access (read from dev)
          echo ""
          echo "ðŸ“‹ Testing Artifact Registry access (cross-project)..."
          if gcloud artifacts docker images describe "${{ env.REGION }}-docker.pkg.dev/${{ env.DEV_PROJECT }}/app-images/fashion-web:latest" --project="${{ env.DEV_PROJECT }}" --quiet > /dev/null 2>&1; then
            echo "âœ… Successfully accessed dev Artifact Registry (cross-project)"
          else
            echo "âš ï¸  Could not verify dev Artifact Registry access (image may not exist)"
          fi

          echo ""
          echo "=========================================="
          echo "âœ… WIF Authentication Verification Complete!"
          echo "=========================================="

      - name: Copy image from dev to prod
        run: |
          VERSION=${GITHUB_REF_NAME#v}
          DEV_IMAGE="${{ env.REGION }}-docker.pkg.dev/${{ env.DEV_PROJECT }}/app-images/fashion-web:$VERSION"
          PROD_IMAGE="${{ env.REGION }}-docker.pkg.dev/${{ env.PROD_PROJECT }}/app-images/fashion-web:$VERSION"

          # Validate dev image exists before attempting copy
          # Prod service account has read access to dev registry (configured in Terraform)
          if ! gcloud artifacts docker images describe "$DEV_IMAGE" --project="${{ env.DEV_PROJECT }}" --quiet 2>/dev/null; then
            echo "âŒ Error: Dev image not found!"
            echo "   Expected: $DEV_IMAGE"
            echo "   Make sure Stage 2 (Build & Deploy Dev) completed successfully."
            exit 1
          fi

          echo "âœ… Found dev image: $DEV_IMAGE"

          # Copy using prod credentials (has read access to dev via IAM, write access to prod)
          gcloud artifacts docker images copy "$DEV_IMAGE" "$PROD_IMAGE" \
            --quiet

      - name: Deploy to prod
        run: |
          VERSION=${GITHUB_REF_NAME#v}
          PROD_IMAGE="${{ env.REGION }}-docker.pkg.dev/${{ env.PROD_PROJECT }}/app-images/fashion-web:$VERSION"

          echo "ðŸš€ Deploying to production (same image as dev)..."
          gcloud run services update fashion-web \
            --image "$PROD_IMAGE" \
            --region="${{ env.REGION }}" \
            --project="${{ env.PROD_PROJECT }}" \
            --quiet

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Release ${{ steps.version.outputs.version }}
          body: |
            ## ðŸš€ Release ${{ steps.version.outputs.version }}

            ${{ steps.changelog.outputs.changelog }}

            ---

            **Full Changelog:** https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ steps.version.outputs.tag }}

            **View CHANGELOG.md:** [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/${{ steps.version.outputs.tag }}/CHANGELOG.md)
          draft: false
          prerelease: false

      - name: Stage 4 complete
        run: |
          echo "âœ… Stage 4 complete: Release created and prod deployed"

  # Stage 1: Bump version and commit
  release:
    name: 'Stage 1: Bump Version'
    runs-on: ubuntu-latest
    needs: check-skip
    # TEMPORARY: Allow PRs for testing (will output dummy version)
    if: needs.check-skip.outputs.skip != 'true' && (github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'pull_request')
    permissions:
      contents: write
    outputs:
      version: ${{ steps.release.outputs.version }}
      needs_release: ${{ steps.release.outputs.needs_release }}
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        continue-on-error: true
        with:
          app-id: ${{ secrets.RELEASE_BOT_CLIENT_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}
          installation-id: ${{ secrets.RELEASE_BOT_INSTALLATION_ID }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token || secrets.GITHUB_PAT || secrets.GITHUB_TOKEN }}

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Generate changelog and bump version
        id: release
        run: |
          # TEMPORARY: For PRs, just output a test version
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "needs_release=false" >> $GITHUB_OUTPUT
            CURRENT_VERSION=$(node -p "require('./package.json').version")
            PR_NUMBER="${{ github.event.pull_request.number }}"
            echo "version=${CURRENT_VERSION}-pr${PR_NUMBER}" >> $GITHUB_OUTPUT
            echo "ðŸ§ª PR test mode: Using version ${CURRENT_VERSION}-pr${PR_NUMBER}"
            exit 0
          fi

          export HUSKY=0 SKIP_COMMIT=true SKIP_TAG=true
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          COMMITS=$(if [ -n "$LAST_TAG" ]; then git log ${LAST_TAG}..HEAD --oneline --grep="^chore(release):" --invert-grep || echo ""; else git log --oneline --grep="^chore(release):" --invert-grep || echo ""; fi)
          if [ -z "$COMMITS" ]; then
            echo "needs_release=false" >> $GITHUB_OUTPUT
            echo "version=" >> $GITHUB_OUTPUT
            exit 0
          fi
          if echo "$COMMITS" | grep -qiE "BREAKING"; then
            npx standard-version --release-as major --skip.commit --skip.tag || true
          elif echo "$COMMITS" | grep -qiE "^[a-f0-9]+.*feat"; then
            npx standard-version --release-as minor --skip.commit --skip.tag || true
          else
            npx standard-version --release-as patch --skip.commit --skip.tag || true
          fi
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "needs_release=true" >> $GITHUB_OUTPUT

      - name: Commit version and changelog
        if: steps.release.outputs.needs_release == 'true'
        run: |
          git add package.json pnpm-lock.yaml CHANGELOG.md
          if ! git diff --staged --quiet; then
            git commit -m "chore(release): ${{ steps.release.outputs.version }}"
            git push origin main
            echo "âœ… Stage 1 complete: Version ${{ steps.release.outputs.version }} committed"
          else
            echo "âš ï¸  No changes to commit"
            echo "needs_release=false" >> $GITHUB_OUTPUT
          fi

  # Stage 2: Build once, deploy everywhere
  build-image:
    name: 'Stage 2: Build Docker Image'
    runs-on: ubuntu-latest
    needs: [check-skip, release]
    # TEMPORARY: Allow PRs for testing WIF authentication
    if: |
      needs.check-skip.outputs.skip != 'true' && (
        (github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.release.outputs.needs_release == 'true') ||
        (github.event_name == 'pull_request')
      )
    permissions:
      contents: read
      id-token: write
    outputs:
      image_version: ${{ steps.build.outputs.version }}
      image_sha: ${{ steps.build.outputs.sha }}
      image_uri: ${{ steps.build.outputs.image_uri }}
    steps:
      # WIF: Authenticate to dev project to build and push image
      - name: Debug GitHub Context
        run: |
          echo "Repository: ${{ github.repository }}"
          echo "Repository Owner: ${{ github.repository_owner }}"
          echo "Event Name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "WIF Provider: ${{ secrets.WIF_PROVIDER_DEV }}"
          echo "Service Account: ${{ secrets.WIF_SERVICE_ACCOUNT_DEV }}"

      - name: Authenticate to Google Cloud (WIF)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER_DEV }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT_DEV }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      # TEMPORARY: Verify WIF authentication is working
      - name: Verify WIF Authentication
        run: |
          echo "ðŸ” Verifying WIF authentication..."
          echo "=========================================="

          # Check current authenticated account
          echo "ðŸ“‹ Current authenticated account:"
          gcloud auth list || echo "âŒ Failed to list auth accounts"

          # Get current project
          echo ""
          echo "ðŸ“‹ Current project:"
          gcloud config get-value project || echo "âŒ Failed to get project"

          # Test basic GCP access
          echo ""
          echo "ðŸ“‹ Testing GCP access..."
          if gcloud projects describe "${{ env.DEV_PROJECT }}" --format="value(projectId)" > /dev/null 2>&1; then
            echo "âœ… Successfully accessed project: ${{ env.DEV_PROJECT }}"
          else
            echo "âŒ Failed to access project: ${{ env.DEV_PROJECT }}"
            exit 1
          fi

          # Test Artifact Registry access
          echo ""
          echo "ðŸ“‹ Testing Artifact Registry access..."
          if gcloud artifacts repositories list --project="${{ env.DEV_PROJECT }}" --format="value(name)" > /dev/null 2>&1; then
            echo "âœ… Successfully accessed Artifact Registry"
          else
            echo "âŒ Failed to access Artifact Registry"
            exit 1
          fi

          # Test Cloud Run access
          echo ""
          echo "ðŸ“‹ Testing Cloud Run access..."
          if gcloud run services list --project="${{ env.DEV_PROJECT }}" --region="${{ env.REGION }}" --format="value(name)" > /dev/null 2>&1; then
            echo "âœ… Successfully accessed Cloud Run"
          else
            echo "âŒ Failed to access Cloud Run"
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "âœ… WIF Authentication Verification Complete!"
          echo "=========================================="

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Get dev service URL
        id: service-url
        run: |
          SERVICE_URL=$(gcloud run services describe fashion-web-dev \
            --region="${{ env.REGION }}" \
            --project="${{ env.DEV_PROJECT }}" \
            --format='value(status.url)' 2>/dev/null || echo "")
          if [ -z "$SERVICE_URL" ]; then
            echo "âš ï¸  Dev service not found, using placeholder"
            SERVICE_URL="https://fashion-web-dev-XXXXXX.run.app"
          fi
          echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Using NEXT_PUBLIC_SERVER_URL: $SERVICE_URL"

      - name: Build and push Docker image
        id: build
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          # TEMPORARY: Use test version for PRs, actual version for main branch
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            VERSION="pr-test-${SHORT_SHA}"
            echo "ðŸ§ª PR test mode: Using version $VERSION"
          else
            VERSION="${{ needs.release.outputs.version }}"
          fi
          IMAGE_SHA="${{ env.REGION }}-docker.pkg.dev/${{ env.DEV_PROJECT }}/app-images/fashion-web:$SHORT_SHA"
          IMAGE_VERSION="${{ env.REGION }}-docker.pkg.dev/${{ env.DEV_PROJECT }}/app-images/fashion-web:$VERSION"
          IMAGE_LATEST="${{ env.REGION }}-docker.pkg.dev/${{ env.DEV_PROJECT }}/app-images/fashion-web:latest"

          # WIF: Authenticate Docker using access token from Application Default Credentials
          # The google-github-actions/auth action sets up GOOGLE_APPLICATION_CREDENTIALS
          # Use Python to get token from ADC (more reliable than gcloud auth print-access-token)
          echo "ðŸ” Authenticating Docker to Artifact Registry..."
          TOKEN=$(python3 -c "import os,subprocess,sys;exec(\"try:\\n from google.auth import default\\n from google.auth.transport.requests import Request\\n credentials, project = default()\\n credentials.refresh(Request())\\n print(credentials.token)\\nexcept ImportError:\\n try:\\n  result = subprocess.run(['gcloud','auth','application-default','print-access-token'],capture_output=True,text=True,check=True)\\n  print(result.stdout.strip())\\n except:\\n  result = subprocess.run(['gcloud','auth','print-access-token'],capture_output=True,text=True,check=True)\\n  print(result.stdout.strip())\\nexcept Exception:\\n sys.exit(1)\")")
          
          if [ -z "$TOKEN" ]; then
            echo "âŒ Failed to get access token"
            exit 1
          fi
          
          echo "$TOKEN" | docker login -u oauth2accesstoken --password-stdin ${{ env.REGION }}-docker.pkg.dev
          echo "âœ… Docker authenticated to Artifact Registry"

          export DOCKER_BUILDKIT=1
          export BUILDKIT_PROGRESS=plain

          # Pull cache from latest (more likely to exist than version tag)
          # Better error handling to distinguish "not found" vs "pull failed"
          CACHE_FROM=""
          CACHE_PULL_OUTPUT=""
          CACHE_PULL_STATUS=0
          CACHE_PULL_OUTPUT=$(docker pull "$IMAGE_LATEST" 2>&1) || CACHE_PULL_STATUS=$?
          if [ "$CACHE_PULL_STATUS" -eq 0 ]; then
            CACHE_FROM="--cache-from $IMAGE_LATEST"
            echo "âœ… Using cache from $IMAGE_LATEST"
          else
            if echo "$CACHE_PULL_OUTPUT" | grep -qiE "not found|manifest unknown"; then
              echo "::notice::Cache image $IMAGE_LATEST not found; proceeding without cache."
            else
              echo "::warning::Failed to pull cache image $IMAGE_LATEST (exit code $CACHE_PULL_STATUS); proceeding without cache."
              echo "$CACHE_PULL_OUTPUT"
            fi
          fi

          # Build once - same image for all environments
          # Note: NEXT_PUBLIC_SERVER_URL uses actual dev service URL (build-once-deploy-anywhere limitation)
          docker build \
            -t "$IMAGE_SHA" \
            -t "$IMAGE_VERSION" \
            -t "$IMAGE_LATEST" \
            --build-arg NEXT_PUBLIC_SERVER_URL="${{ steps.service-url.outputs.url }}" \
            --build-arg PAYLOAD_SECRET="dummy-secret-for-build" \
            --build-arg DATABASE_URI="postgres://dummy:dummy@localhost:5432/dummy" \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            $CACHE_FROM \
            .

          # Push image (authentication already established)
          docker push "$IMAGE_SHA"
          docker push "$IMAGE_VERSION"
          docker push "$IMAGE_LATEST"

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "image_uri=$IMAGE_VERSION" >> $GITHUB_OUTPUT

  deploy-dev:
    name: 'Deploy to Dev'
    runs-on: ubuntu-latest
    needs: [check-skip, build-image]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.check-skip.outputs.skip != 'true'
    environment:
      name: dev
    permissions:
      id-token: write
      contents: none
    steps:
      # WIF: Authenticate to dev project for deployment
      - name: Authenticate to Google Cloud (WIF)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER_DEV }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT_DEV }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      # TEMPORARY: Verify WIF authentication is working
      - name: Verify WIF Authentication
        run: |
          echo "ðŸ” Verifying WIF authentication (deploy-dev)..."
          echo "=========================================="

          # Check current authenticated account
          echo "ðŸ“‹ Current authenticated account:"
          gcloud auth list || echo "âŒ Failed to list auth accounts"

          # Test Cloud Run access
          echo ""
          echo "ðŸ“‹ Testing Cloud Run access..."
          if gcloud run services list --project="${{ env.DEV_PROJECT }}" --region="${{ env.REGION }}" --format="value(name)" > /dev/null 2>&1; then
            echo "âœ… Successfully accessed Cloud Run"
          else
            echo "âŒ Failed to access Cloud Run"
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "âœ… WIF Authentication Verification Complete!"
          echo "=========================================="

      - name: Deploy to dev
        run: |
          IMAGE="${{ needs.build-image.outputs.image_uri }}"
          echo "ðŸš€ Deploying $IMAGE to dev..."
          gcloud run services update fashion-web-dev \
            --image "$IMAGE" \
            --region="${{ env.REGION }}" \
            --project="${{ env.DEV_PROJECT }}" \
            --quiet

  # Stage 3: Create tag
  create-tag:
    name: 'Stage 3: Create Tag'
    runs-on: ubuntu-latest
    needs: [check-skip, release, build-image]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.check-skip.outputs.skip != 'true' && needs.release.outputs.needs_release == 'true'
    permissions:
      contents: write
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        continue-on-error: true
        with:
          app-id: ${{ secrets.RELEASE_BOT_CLIENT_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}
          installation-id: ${{ secrets.RELEASE_BOT_INSTALLATION_ID }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token || secrets.GITHUB_PAT || secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Create and push git tag
        run: |
          VERSION=${{ needs.release.outputs.version }}
          git tag -a "v$VERSION" -m "chore(release): $VERSION"
          git push origin "v$VERSION"
          echo "âœ… Stage 3 complete: Git tag v$VERSION created and pushed"

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [check-skip, create-github-release]
    if: github.event_name == 'push' && github.ref_type == 'tag' && needs.check-skip.outputs.skip != 'true'
    steps:
      # WIF: Authenticate to prod (job only runs on tags)
      - name: Authenticate to Google Cloud (WIF)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER_PROD }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT_PROD }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Health check
        run: |
          sleep 30
          SERVICE_NAME="fashion-web"
          SERVICE_URL=$(gcloud run services describe "$SERVICE_NAME" \
            --region="${{ env.REGION }}" \
            --project="${{ env.PROD_PROJECT }}" \
            --format='value(status.url)' 2>/dev/null || echo "")
          if [ -z "$SERVICE_URL" ]; then
            exit 0
          fi
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$SERVICE_URL" || echo "000")
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "301" ] && [ "$HTTP_CODE" != "302" ]; then
            exit 1
          fi
