name: CI/CD Pipeline

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  pull_request:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref_name }}
  cancel-in-progress: true

permissions:
  contents: write
  id-token: write
  pull-requests: write

env:
  REGION: asia-southeast1
  DEV_PROJECT: the-white-dev-481217
  PROD_PROJECT: the-white-prod-481217

jobs:
  cancel-cloud-builds:
    name: Cancel Cloud Builds
    runs-on: ubuntu-latest
    # Note: This cancels any old Cloud Build runs (if triggers are still active).
    # Cloud Build triggers should be disabled - all builds happen in GitHub Actions.
    steps:
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For PRs, cancel builds for the PR branch
            BRANCH_NAME="${{ github.head_ref }}"
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "project_id=${{ env.DEV_PROJECT }}" >> $GITHUB_OUTPUT
            echo "filter=source.repoSource.branchName=$BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref_type }}" = "tag" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "project_id=${{ env.PROD_PROJECT }}" >> $GITHUB_OUTPUT
            echo "filter=source.repoSource.tagName=${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "branch_name=" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "project_id=${{ env.DEV_PROJECT }}" >> $GITHUB_OUTPUT
            echo "filter=source.repoSource.branchName=${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "branch_name=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Authenticate to Google Cloud
        if: steps.env.outputs.project_id != ''
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ steps.env.outputs.environment == 'prod' && 'projects/570865959950/locations/global/workloadIdentityPools/github-actions-pool/providers/github-actions-provider' || 'projects/635555941174/locations/global/workloadIdentityPools/github-actions-pool/providers/github-actions-provider' }}
          service_account: github-actions-deployer@${{ steps.env.outputs.project_id }}.iam.gserviceaccount.com

      - name: Set up Cloud SDK
        if: steps.env.outputs.project_id != ''
        uses: google-github-actions/setup-gcloud@v2

      - name: Cancel previous builds
        if: steps.env.outputs.project_id != ''
        run: |
          FILTER="${{ steps.env.outputs.filter }}"
          COMMIT_SHA="${{ github.sha }}"
          SHORT_SHA="${COMMIT_SHA:0:7}"
          BRANCH_NAME="${{ steps.env.outputs.branch_name }}"

          echo "ðŸ” Looking for builds to cancel..."
          echo "   Filter: $FILTER"
          echo "   Commit SHA: $SHORT_SHA"
          echo "   Branch: $BRANCH_NAME"
          echo "   Event: ${{ github.event_name }}"

          # For branch-based cancellation, we'll cancel all builds that:
          # 1. Match the branch name (if available), OR
          # 2. Are trigger-based builds (no branch name) from the same branch context
          # Since trigger-based builds don't have branch info, we cancel all that aren't current commit
          # when we're filtering by branch (safe because we know the context)

          # Extract filter value (branch or tag name)
          if echo "$FILTER" | grep -q "branchName="; then
            FILTER_VALUE=$(echo "$FILTER" | sed 's/.*branchName=//')
            FILTER_TYPE="branch"
          elif echo "$FILTER" | grep -q "tagName="; then
            FILTER_VALUE=$(echo "$FILTER" | sed 's/.*tagName=//')
            FILTER_TYPE="tag"
          else
            FILTER_VALUE=""
            FILTER_TYPE="unknown"
          fi

          echo "   Event: ${{ github.event_name }}"
          echo "   Filter type: $FILTER_TYPE"
          echo "   Filter value: $FILTER_VALUE"
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "   PR branch: ${{ github.head_ref }}"
          fi

          # Get all queued/working builds
          RUNNING_BUILDS=$(gcloud builds list \
            --region="${{ env.REGION }}" \
            --project="${{ steps.env.outputs.project_id }}" \
            --filter="status=WORKING OR status=QUEUED" \
            --format="value(id)" \
            --limit=100 2>/dev/null || echo "")

          if [ -z "$RUNNING_BUILDS" ]; then
            echo "â„¹ï¸  No running/queued builds found"
            exit 0
          fi

          CANCEL_COUNT=0
          for BUILD_ID in $RUNNING_BUILDS; do
            # Get build details
            BUILD_INFO=$(gcloud builds describe "$BUILD_ID" \
              --region="${{ env.REGION }}" \
              --project="${{ steps.env.outputs.project_id }}" \
              --format="json" 2>/dev/null || echo "{}")
            
            if [ "$BUILD_INFO" = "{}" ]; then
              continue
            fi
            
            # Extract branch, tag, and commit SHA from build
            # Try repoSource first (for gcloud builds submit)
            BUILD_BRANCH=$(echo "$BUILD_INFO" | grep -o '"branchName": "[^"]*"' | cut -d'"' -f4 || echo "")
            BUILD_TAG=$(echo "$BUILD_INFO" | grep -o '"tagName": "[^"]*"' | cut -d'"' -f4 || echo "")
            BUILD_SHA=$(echo "$BUILD_INFO" | grep -o '"commitSha": "[^"]*"' | cut -d'"' -f4 || echo "")
            
            # If no commit SHA from repoSource, try gitSource.revision (for Cloud Build triggers)
            if [ -z "$BUILD_SHA" ]; then
              BUILD_SHA=$(echo "$BUILD_INFO" | grep -o '"revision": "[^"]*"' | cut -d'"' -f4 || echo "")
            fi
            
            BUILD_SHORT_SHA="${BUILD_SHA:0:7}"
            
            # For trigger-based builds without branch info, try to get branch from substitutions
            if [ -z "$BUILD_BRANCH" ] && [ -n "$BUILD_SHA" ]; then
              # Check substitutions for branch name
              BUILD_BRANCH_SUB=$(echo "$BUILD_INFO" | grep -o '"BRANCH_NAME": "[^"]*"' | cut -d'"' -f4 || echo "")
              if [ -n "$BUILD_BRANCH_SUB" ]; then
                BUILD_BRANCH="$BUILD_BRANCH_SUB"
              fi
            fi
            
            # Check if build matches our filter
            SHOULD_CANCEL=false
            MATCH_REASON=""
            
            if [ "$FILTER_TYPE" = "branch" ] && [ "$BUILD_BRANCH" = "$FILTER_VALUE" ]; then
              SHOULD_CANCEL=true
              MATCH_REASON="branch match ($BUILD_BRANCH)"
            elif [ "$FILTER_TYPE" = "tag" ] && [ "$BUILD_TAG" = "$FILTER_VALUE" ]; then
              SHOULD_CANCEL=true
              MATCH_REASON="tag match ($BUILD_TAG)"
            elif [ -n "$BUILD_SHORT_SHA" ] && [ "$BUILD_SHORT_SHA" = "$SHORT_SHA" ]; then
              # Don't cancel the current build
              SHOULD_CANCEL=false
            elif [ "$FILTER_TYPE" = "branch" ] && [ -z "$BUILD_BRANCH" ] && [ -n "$BUILD_SHA" ] && [ -n "$BRANCH_NAME" ]; then
              # For trigger-based builds without branch info, cancel all builds that aren't the current commit
              # This is safe when filtering by branch because:
              # 1. We know the branch context from the PR/push event
              # 2. Trigger-based builds from the same branch won't have branch name set
              # 3. We only want the latest build for this branch to run
              if [ "$BUILD_SHORT_SHA" != "$SHORT_SHA" ]; then
                SHOULD_CANCEL=true
                MATCH_REASON="trigger-based build from branch $BRANCH_NAME (older commit: $BUILD_SHORT_SHA)"
              fi
            fi
            
            # Debug: show all builds being checked
            echo "   Build $BUILD_ID: branch=$BUILD_BRANCH, tag=$BUILD_TAG, sha=$BUILD_SHORT_SHA"
            
            if [ "$SHOULD_CANCEL" = "true" ]; then
              echo "ðŸ›‘ Canceling build: $BUILD_ID (reason: $MATCH_REASON)"
              if gcloud builds cancel "$BUILD_ID" \
                --region="${{ env.REGION }}" \
                --project="${{ steps.env.outputs.project_id }}" \
                --quiet 2>/dev/null; then
                CANCEL_COUNT=$((CANCEL_COUNT + 1))
                echo "   âœ… Successfully canceled"
              else
                echo "   âš ï¸  Failed to cancel (may have already finished)"
              fi
            else
              echo "   â­ï¸  Skipping (doesn't match filter)"
            fi
          done

          echo ""
          if [ $CANCEL_COUNT -gt 0 ]; then
            echo "âœ… Canceled $CANCEL_COUNT previous build(s)"
          else
            echo "â„¹ï¸  No matching builds to cancel"
            echo "   (Checked all queued/working builds but none matched the filter)"
          fi

  quality:
    name: Quality Checks
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Generate GitHub App Token
        id: app-token
        if: github.event_name == 'pull_request'
        uses: actions/create-github-app-token@v1
        continue-on-error: true
        with:
          app-id: ${{ secrets.RELEASE_BOT_CLIENT_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}
          installation-id: ${{ secrets.RELEASE_BOT_INSTALLATION_ID }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token || secrets.GITHUB_PAT || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Auto-fix formatting
        id: format
        run: |
          pnpm format || true
          if ! git diff --quiet; then
            git add -A
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit formatting fixes
        if: github.event_name == 'pull_request' && steps.format.outputs.has_changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          if ! git diff --staged --quiet; then
            git commit -m "style: auto-fix formatting issues" || exit 0
            git push origin HEAD:${{ github.head_ref }} || true
          fi

      - name: Verify formatting
        run: pnpm format:check

      - name: Run linter
        run: pnpm lint

      - name: Type check
        run: npx tsc --noEmit

  build:
    name: Build (CI Validation)
    runs-on: ubuntu-latest
    needs: [quality]
    if: github.event_name == 'pull_request'
    # Note: This is a fast CI validation build (pnpm build) that doesn't create Docker images.
    # Docker builds and deployments happen in the deploy job (GitHub Actions only, no Cloud Build).
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build application
        run: pnpm build
        env:
          NODE_ENV: production
          NEXT_PUBLIC_SERVER_URL: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && 'https://fashion-web-dev-XXXXXX.run.app' || 'http://localhost:3000' }}
          PAYLOAD_SECRET: dummy-secret-for-build
          DATABASE_URI: dummy-uri-for-build

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: [cancel-cloud-builds]
    if: github.event_name == 'push' && github.ref_type == 'tag'
    environment:
      name: ${{ startsWith(github.ref_name, 'v') && 'prod' || 'dev' }}
    steps:
      - name: Determine deployment parameters
        id: params
        run: |
          if [ "${{ startsWith(github.ref_name, 'v') }}" = "true" ]; then
            echo "project_id=${{ env.PROD_PROJECT }}" >> $GITHUB_OUTPUT
            echo "service_name=fashion-web" >> $GITHUB_OUTPUT
            echo "service_account=github-actions-deployer@${{ env.PROD_PROJECT }}.iam.gserviceaccount.com" >> $GITHUB_OUTPUT
            echo "workload_identity_provider=projects/570865959950/locations/global/workloadIdentityPools/github-actions-pool/providers/github-actions-provider" >> $GITHUB_OUTPUT
            echo "next_public_server_url=https://fashion-web-XXXXXX.run.app" >> $GITHUB_OUTPUT
            echo "environment=prod" >> $GITHUB_OUTPUT
          else
            echo "project_id=${{ env.DEV_PROJECT }}" >> $GITHUB_OUTPUT
            echo "service_name=fashion-web-dev" >> $GITHUB_OUTPUT
            echo "service_account=github-actions-deployer@${{ env.DEV_PROJECT }}.iam.gserviceaccount.com" >> $GITHUB_OUTPUT
            echo "workload_identity_provider=projects/635555941174/locations/global/workloadIdentityPools/github-actions-pool/providers/github-actions-provider" >> $GITHUB_OUTPUT
            echo "next_public_server_url=https://fashion-web-dev-XXXXXX.run.app" >> $GITHUB_OUTPUT
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
          echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ steps.params.outputs.workload_identity_provider }}
          service_account: ${{ steps.params.outputs.service_account }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ format('refs/tags/{0}', github.ref_name) }}

      - name: Configure Docker for Artifact Registry
        if: steps.params.outputs.environment == 'dev'
        run: |
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet

      - name: Fetch secrets for Docker build
        if: steps.params.outputs.environment == 'dev'
        id: secrets
        run: |
          PAYLOAD_SECRET=$(gcloud secrets versions access latest --secret=PAYLOAD_SECRET_DEV --project="${{ steps.params.outputs.project_id }}" 2>/dev/null || echo "")
          DATABASE_URI=$(gcloud secrets versions access latest --secret=DATABASE_URI_DEV --project="${{ steps.params.outputs.project_id }}" 2>/dev/null || echo "")
          echo "::add-mask::$PAYLOAD_SECRET"
          echo "::add-mask::$DATABASE_URI"
          echo "payload_secret=$PAYLOAD_SECRET" >> $GITHUB_OUTPUT
          echo "database_uri=$DATABASE_URI" >> $GITHUB_OUTPUT

      - name: Build and push Docker image to dev
        if: steps.params.outputs.environment == 'dev'
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          VERSION=$(node -p "require('./package.json').version")
          IMAGE_SHA="${{ env.REGION }}-docker.pkg.dev/${{ steps.params.outputs.project_id }}/app-images/fashion-web:$SHORT_SHA"
          IMAGE_VERSION="${{ env.REGION }}-docker.pkg.dev/${{ steps.params.outputs.project_id }}/app-images/fashion-web:$VERSION"
          IMAGE_LATEST="${{ env.REGION }}-docker.pkg.dev/${{ steps.params.outputs.project_id }}/app-images/fashion-web:latest"

          echo "ðŸ”¨ Building Docker image (version: $VERSION)..."
          export DOCKER_BUILDKIT=1
          docker build \
            -t $IMAGE_SHA \
            -t $IMAGE_VERSION \
            -t $IMAGE_LATEST \
            --build-arg NEXT_PUBLIC_SERVER_URL="${{ steps.params.outputs.next_public_server_url }}" \
            --build-arg PAYLOAD_SECRET="${{ steps.secrets.outputs.payload_secret }}" \
            --build-arg DATABASE_URI="${{ steps.secrets.outputs.database_uri }}" \
            --cache-from $IMAGE_LATEST \
            .

          echo "ðŸ“¤ Pushing images..."
          docker push $IMAGE_SHA
          docker push $IMAGE_VERSION
          docker push $IMAGE_LATEST
          echo "âœ… Images pushed: $IMAGE_SHA, $IMAGE_VERSION, $IMAGE_LATEST"

      - name: Deploy to dev
        if: steps.params.outputs.environment == 'dev'
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          IMAGE="${{ env.REGION }}-docker.pkg.dev/${{ steps.params.outputs.project_id }}/app-images/fashion-web:$SHORT_SHA"
          echo "ðŸš€ Deploying to dev..."
          gcloud run services update ${{ steps.params.outputs.service_name }} \
            --image $IMAGE \
            --region="${{ env.REGION }}" \
            --project="${{ steps.params.outputs.project_id }}" \
            --quiet
          echo "âœ… Dev deployment complete"

      - name: Authenticate to dev for image copy
        if: steps.params.outputs.environment == 'prod'
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: projects/635555941174/locations/global/workloadIdentityPools/github-actions-pool/providers/github-actions-provider
          service_account: github-actions-deployer@${{ env.DEV_PROJECT }}.iam.gserviceaccount.com

      - name: Set up Cloud SDK for image copy
        if: steps.params.outputs.environment == 'prod'
        uses: google-github-actions/setup-gcloud@v2

      - name: Copy image from dev to prod
        if: steps.params.outputs.environment == 'prod'
        run: |
          VERSION=${GITHUB_REF_NAME#v}
          TAG_SHA=$(git rev-parse ${{ github.ref_name }})
          SHORT_SHA=$(git rev-parse --short $TAG_SHA)
          DEV_IMAGE="${{ env.REGION }}-docker.pkg.dev/${{ env.DEV_PROJECT }}/app-images/fashion-web:$VERSION"
          PROD_IMAGE="${{ env.REGION }}-docker.pkg.dev/${{ env.PROD_PROJECT }}/app-images/fashion-web:$VERSION"
          PROD_IMAGE_LATEST="${{ env.REGION }}-docker.pkg.dev/${{ env.PROD_PROJECT }}/app-images/fashion-web:latest"
          PROD_IMAGE_SHA="${{ env.REGION }}-docker.pkg.dev/${{ env.PROD_PROJECT }}/app-images/fashion-web:$SHORT_SHA"

          echo "ðŸ”„ Copying image from dev to prod..."
          echo "   Version: $VERSION"
          echo "   Source: $DEV_IMAGE"
          echo "   Targets: $PROD_IMAGE, $PROD_IMAGE_LATEST, $PROD_IMAGE_SHA"

          if ! gcloud artifacts docker images describe $DEV_IMAGE --project="${{ env.DEV_PROJECT }}" --quiet 2>/dev/null; then
            echo "âŒ Error: Dev image $DEV_IMAGE not found!"
            echo "   Make sure the image was built and deployed to dev first."
            exit 1
          fi

          gcloud artifacts docker images copy $DEV_IMAGE $PROD_IMAGE \
            --project="${{ env.PROD_PROJECT }}" \
            --quiet || echo "âš ï¸  Failed to copy version tag (may already exist)"

          gcloud artifacts docker images copy $DEV_IMAGE $PROD_IMAGE_LATEST \
            --project="${{ env.PROD_PROJECT }}" \
            --quiet || echo "âš ï¸  Failed to copy latest tag"

          gcloud artifacts docker images copy $DEV_IMAGE $PROD_IMAGE_SHA \
            --project="${{ env.PROD_PROJECT }}" \
            --quiet || echo "âš ï¸  Failed to copy SHA tag"

          echo "âœ… Image copy completed"

      - name: Configure Docker for Artifact Registry (prod)
        if: steps.params.outputs.environment == 'prod'
        run: |
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet

      - name: Deploy to prod
        if: steps.params.outputs.environment == 'prod'
        run: |
          VERSION=${GITHUB_REF_NAME#v}
          TAG_SHA=$(git rev-parse ${{ github.ref_name }})
          SHORT_SHA=$(git rev-parse --short $TAG_SHA)
          PROD_IMAGE="${{ env.REGION }}-docker.pkg.dev/${{ env.PROD_PROJECT }}/app-images/fashion-web:$SHORT_SHA"

          echo "ðŸš€ Deploying to production..."
          echo "   Version: $VERSION"
          echo "   Image: $PROD_IMAGE"

          gcloud run services update fashion-web \
            --image $PROD_IMAGE \
            --region="${{ env.REGION }}" \
            --project="${{ env.PROD_PROJECT }}" \
            --quiet

          echo "âœ… Production deployment complete"

  release:
    name: Release
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: write
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        continue-on-error: true
        with:
          app-id: ${{ secrets.RELEASE_BOT_CLIENT_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}
          installation-id: ${{ secrets.RELEASE_BOT_INSTALLATION_ID }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token || secrets.GITHUB_PAT || secrets.GITHUB_TOKEN }}

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Generate changelog and bump version
        id: release
        run: |
          export HUSKY=0 SKIP_COMMIT=true SKIP_TAG=true
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          COMMITS=$(if [ -n "$LAST_TAG" ]; then git log ${LAST_TAG}..HEAD --oneline --grep="^chore(release):" --invert-grep || echo ""; else git log --oneline --grep="^chore(release):" --invert-grep || echo ""; fi)
          if [ -z "$COMMITS" ]; then
            echo "needs_release=false" >> $GITHUB_ENV
            exit 0
          fi
          if echo "$COMMITS" | grep -qiE "BREAKING"; then
            npx standard-version --release-as major --skip.commit --skip.tag || true
          elif echo "$COMMITS" | grep -qiE "^[a-f0-9]+.*feat"; then
            npx standard-version --release-as minor --skip.commit --skip.tag || true
          else
            npx standard-version --release-as patch --skip.commit --skip.tag || true
          fi
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "needs_release=true" >> $GITHUB_ENV

      - name: Commit version and changelog
        if: env.needs_release == 'true'
        run: |
          git add package.json pnpm-lock.yaml CHANGELOG.md
          if ! git diff --staged --quiet; then
            git commit -m "chore(release): ${{ steps.release.outputs.version }}"
            git push origin main
            echo "âœ… Version and changelog committed"
          else
            echo "âš ï¸  No changes to commit"
            echo "needs_release=false" >> $GITHUB_ENV
          fi

      - name: Create and push git tag
        if: env.needs_release == 'true'
        run: |
          git tag -a "v${{ steps.release.outputs.version }}" -m "chore(release): ${{ steps.release.outputs.version }}"
          git push origin "v${{ steps.release.outputs.version }}"
          echo "âœ… Git tag v${{ steps.release.outputs.version }} created and pushed"

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy]
    if: github.event_name == 'push'
    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ github.ref_type == 'tag' && 'projects/570865959950/locations/global/workloadIdentityPools/github-actions-pool/providers/github-actions-provider' || 'projects/635555941174/locations/global/workloadIdentityPools/github-actions-pool/providers/github-actions-provider' }}
          service_account: github-actions-deployer@${{ github.ref_type == 'tag' && env.PROD_PROJECT || env.DEV_PROJECT }}.iam.gserviceaccount.com

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Health check
        run: |
          sleep 30
          SERVICE_NAME="${{ github.ref_type == 'tag' && 'fashion-web' || 'fashion-web-dev' }}"
          SERVICE_URL=$(gcloud run services describe "$SERVICE_NAME" \
            --region="${{ env.REGION }}" \
            --project="${{ github.ref_type == 'tag' && env.PROD_PROJECT || env.DEV_PROJECT }}" \
            --format='value(status.url)' 2>/dev/null || echo "")
          if [ -z "$SERVICE_URL" ]; then
            exit 0
          fi
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$SERVICE_URL" || echo "000")
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "301" ] && [ "$HTTP_CODE" != "302" ]; then
            exit 1
          fi
