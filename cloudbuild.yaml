steps:
  # 0. Cancel previous builds for the same branch/commit
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "üõë Canceling previous builds for this branch..."

        # Get current build ID and source information
        CURRENT_BUILD_ID="${BUILD_ID}"
        CURRENT_BRANCH="${BRANCH_NAME:-${TAG_NAME:-main}}"
        CURRENT_SHA="${COMMIT_SHA:-${SHORT_SHA}}"

        echo "Current build: $${CURRENT_BUILD_ID}"
        echo "Branch/Tag: $${CURRENT_BRANCH}"
        echo "Commit SHA: $${CURRENT_SHA}"

        # List all running builds for this project and region
        RUNNING_BUILDS=$(gcloud builds list \
          --region=${_REGION} \
          --project=${PROJECT_ID} \
          --filter="status=WORKING OR status=QUEUED" \
          --format="value(id)" \
          --limit=50 2>/dev/null || echo "")

        if [ -n "$$RUNNING_BUILDS" ]; then
          echo "Checking running/queued builds for same branch..."
          CANCELED_COUNT=0
          
          # Check each build to see if it's from the same branch
          for BUILD_ID in $$RUNNING_BUILDS; do
            if [ "$$BUILD_ID" = "$$CURRENT_BUILD_ID" ]; then
              continue
            fi
            
            # Get build source information
            BUILD_BRANCH=$(gcloud builds describe "$$BUILD_ID" \
              --region=${_REGION} \
              --project=${PROJECT_ID} \
              --format="value(source.repoSource.branchName)" 2>/dev/null || echo "")
            
            BUILD_TAG=$(gcloud builds describe "$$BUILD_ID" \
              --region=${_REGION} \
              --project=${PROJECT_ID} \
              --format="value(source.repoSource.tagName)" 2>/dev/null || echo "")
            
            # Also check substitutions as fallback
            if [ -z "$$BUILD_BRANCH" ] && [ -z "$$BUILD_TAG" ]; then
              BUILD_BRANCH=$(gcloud builds describe "$$BUILD_ID" \
                --region=${_REGION} \
                --project=${PROJECT_ID} \
                --format="value(substitutions.BRANCH_NAME)" 2>/dev/null || echo "")
              
              BUILD_TAG=$(gcloud builds describe "$$BUILD_ID" \
                --region=${_REGION} \
                --project=${PROJECT_ID} \
                --format="value(substitutions.TAG_NAME)" 2>/dev/null || echo "")
            fi
            
            # Check if this build is from the same branch/tag
            SHOULD_CANCEL=false
            if [ -n "$${TAG_NAME:-}" ]; then
              # Tag-based build - cancel if same tag
              if [ "$$BUILD_TAG" = "$${TAG_NAME}" ]; then
                SHOULD_CANCEL=true
              fi
            else
              # Branch-based build - cancel if same branch
              if [ "$$BUILD_BRANCH" = "$$CURRENT_BRANCH" ]; then
                SHOULD_CANCEL=true
              fi
            fi
            
            if [ "$$SHOULD_CANCEL" = "true" ]; then
              echo "Canceling build from same branch/tag: $${BUILD_ID} (branch: $${BUILD_BRANCH:-N/A}, tag: $${BUILD_TAG:-N/A})"
              if gcloud builds cancel "$$BUILD_ID" \
                --region=${_REGION} \
                --project=${PROJECT_ID} \
                --quiet 2>/dev/null; then
                CANCELED_COUNT=$((CANCELED_COUNT + 1))
              else
                echo "  (Build may have already finished)"
              fi
            fi
          done
          
          if [ $$CANCELED_COUNT -gt 0 ]; then
            echo "‚úÖ Canceled $${CANCELED_COUNT} previous build(s) for same branch/tag"
          else
            echo "‚ÑπÔ∏è  No previous builds found for same branch/tag"
          fi
        else
          echo "‚ÑπÔ∏è  No running/queued builds to check"
        fi

  # 1. Fetch secrets from Secret Manager
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Determine secret names based on project
        if [ "${PROJECT_ID}" = "the-white-prod-481217" ]; then
          PAYLOAD_SECRET_NAME="PAYLOAD_SECRET"
          DATABASE_URI_NAME="DATABASE_URI"
        elif [ "${PROJECT_ID}" = "the-white-dev-481217" ]; then
          PAYLOAD_SECRET_NAME="PAYLOAD_SECRET_DEV"
          DATABASE_URI_NAME="DATABASE_URI_DEV"
        else
          PAYLOAD_SECRET_NAME="PAYLOAD_SECRET"
          DATABASE_URI_NAME="DATABASE_URI"
        fi

        # Get secrets from Secret Manager
        echo "üîê Fetching secrets from Secret Manager..."
        echo "   Project: ${PROJECT_ID}"
        echo "   Looking for: $$PAYLOAD_SECRET_NAME"

        # Try to fetch PAYLOAD_SECRET - show error if it fails
        PAYLOAD_SECRET_OUTPUT=$$(gcloud secrets versions access latest --secret=$$PAYLOAD_SECRET_NAME --project=${PROJECT_ID} 2>&1)
        PAYLOAD_SECRET_EXIT=$$?

        if [ $$PAYLOAD_SECRET_EXIT -eq 0 ]; then
          PAYLOAD_SECRET="$$PAYLOAD_SECRET_OUTPUT"
          if [ -n "$$PAYLOAD_SECRET" ]; then
            PAYLOAD_SECRET_LEN=$${#PAYLOAD_SECRET}
            echo "‚úÖ PAYLOAD_SECRET fetched successfully ($$PAYLOAD_SECRET_LEN chars)"
            # Write to file for next step
            echo -n "$$PAYLOAD_SECRET" > /workspace/payload_secret.txt
          else
            echo "‚ùå ERROR: PAYLOAD_SECRET is empty!"
            exit 1
          fi
        else
          echo "‚ùå ERROR: Failed to fetch PAYLOAD_SECRET:"
          echo "$$PAYLOAD_SECRET_OUTPUT"
          echo ""
          echo "Possible issues:"
          echo "  1. Secret '$$PAYLOAD_SECRET_NAME' doesn't exist in ${PROJECT_ID}"
          echo "  2. Cloud Build service account lacks permission"
          echo "  3. Secret name is incorrect"
          exit 1
        fi

        # DATABASE_URI is optional for build
        DATABASE_URI=$$(gcloud secrets versions access latest --secret=$$DATABASE_URI_NAME --project=${PROJECT_ID} 2>/dev/null || echo "")
        if [ -n "$$DATABASE_URI" ]; then
          echo "‚úÖ DATABASE_URI fetched successfully"
          echo -n "$$DATABASE_URI" > /workspace/database_uri.txt
        else
          echo "‚ö†Ô∏è  DATABASE_URI not found (optional for build)"
          echo -n "" > /workspace/database_uri.txt
        fi

  # 2. Build the container image
  - name: 'gcr.io/cloud-builders/docker'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Read secrets from files created in previous step
        PAYLOAD_SECRET=$$(cat /workspace/payload_secret.txt)
        DATABASE_URI=$$(cat /workspace/database_uri.txt)

        echo "üî® Building Docker image..."
        echo "   PAYLOAD_SECRET length: $${#PAYLOAD_SECRET} chars"
        echo "   DATABASE_URI length: $${#DATABASE_URI} chars"

        # Enable BuildKit for faster builds with cache mounts
        export DOCKER_BUILDKIT=1
        export BUILDKIT_PROGRESS=plain

        docker build -t ${_REGION}-docker.pkg.dev/${PROJECT_ID}/app-images/fashion-web:${SHORT_SHA} \
                     -t ${_REGION}-docker.pkg.dev/${PROJECT_ID}/app-images/fashion-web:latest \
                     --build-arg NEXT_PUBLIC_SERVER_URL=${_NEXT_PUBLIC_SERVER_URL} \
                     --build-arg PAYLOAD_SECRET="$$PAYLOAD_SECRET" \
                     --build-arg DATABASE_URI="$$DATABASE_URI" \
                     --cache-from ${_REGION}-docker.pkg.dev/${PROJECT_ID}/app-images/fashion-web:latest \
                     .

  # 3. Push the container image to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        docker push ${_REGION}-docker.pkg.dev/${PROJECT_ID}/app-images/fashion-web:${SHORT_SHA}
        docker push ${_REGION}-docker.pkg.dev/${PROJECT_ID}/app-images/fashion-web:latest

  # 4. Deploy to Cloud Run (Update existing service)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Determine service name and environment based on project and trigger
        if [ "${PROJECT_ID}" = "the-white-prod-481217" ]; then
          # Production project - only deploy on tag creation
          service_name="fashion-web"

          # Verify this is a tag-based deployment
          if [ -n "${TAG_NAME}" ]; then
            echo "üè∑Ô∏è  Tag-based deployment to PRODUCTION: ${TAG_NAME}"
          else
            echo "‚ö†Ô∏è  Production deployments require a version tag (e.g., v1.0.0)"
            echo "‚ö†Ô∏è  Skipping deployment..."
            exit 0
          fi

        elif [ "${PROJECT_ID}" = "the-white-dev-481217" ]; then
          # Dev project - deploy on PR to main or manual trigger
          service_name="fashion-web-dev"

          # Log the trigger type
          if [ -n "${_PR_NUMBER:-}" ]; then
            echo "üîÄ PR deployment to DEV: PR #${_PR_NUMBER} targeting main branch"
          elif [ -n "${BRANCH_NAME:-}" ]; then
            echo "üåø Branch deployment to DEV: ${BRANCH_NAME}"
          else
            echo "‚ÑπÔ∏è  Manual deployment to DEV"
          fi

        else
          echo "‚ö†Ô∏è  Unknown project ${PROJECT_ID}. Skipping deployment..."
          exit 0
        fi

        echo "üöÄ Deploying ${SHORT_SHA} to $$service_name in ${PROJECT_ID}..."

        # Only update the image, preserve all other Terraform-managed settings
        gcloud run services update $$service_name \
          --image ${_REGION}-docker.pkg.dev/${PROJECT_ID}/app-images/fashion-web:${SHORT_SHA} \
          --region ${_REGION} \
          --project ${PROJECT_ID} \
          --quiet

        echo "‚úÖ Deployment complete!"
        SERVICE_URL=$$(gcloud run services describe $$service_name --region=${_REGION} --project=${PROJECT_ID} --format='value(status.url)' | cut -d'/' -f3)
        echo "üìä Service URL: https://$$SERVICE_URL"

timeout: 1800s

options:
  logging: CLOUD_LOGGING_ONLY

substitutions:
  _NEXT_PUBLIC_SERVER_URL: '' # Must be provided by trigger or CLI
  _REGION: 'asia-southeast1' # Singapore - closest to Vietnam
